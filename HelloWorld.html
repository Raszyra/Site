<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Hello, World! Prototype</title>
<style>
  body { font-family: Arial, sans-serif; background:#f5f5f5; color:#222; padding:20px;}
  h1,h2,h3 { color:#c00; }
  .card { border:1px solid #333; border-radius:5px; padding:10px; margin:5px; background:#fff;}
  .hand, .program { display:flex; gap:5px; margin:10px 0;}
  .selected { border:2px solid green; }
  #log { border:1px solid #333; height:150px; overflow:auto; background:#eee; padding:5px;}
  button { margin:5px; padding:5px 10px; }
  details { margin:10px 0; }
</style>
</head>
<body>

<h1>Hello, World! Prototype</h1>
<p><em>“Finally, a card game about work!”</em></p>
<p><strong>Prototype:</strong> This is a prototype to gather feedback for the printed product. Questions or feedback? Email: <a href="mailto:faction7entertainment@gmail.com">faction7entertainment@gmail.com</a></p>

<details open>
<summary>Rules</summary>
<div style="padding:10px; background:#fff; border:1px solid #ccc;">
<pre>
Genre: Card
Rated: E
Length: 1-2 hrs
Players: 2+
Pieces: Base 100 card deck + 3 individual ~40 card Language decks

Description:
Complete programs by drawing code structure cards. IT events disrupt or challenge opponents.

Gameplay:
- Hands of 8 cards
- Turns: draw from main deck, draw from code deck, play 1 card of each type
- Game ends: 3 programs (full game) or 1 program (quick game) or deck exhausted
- Must meet function requirements: Variables, Libraries, If/Else, Bonus

Languages:
C++: Use Namespace Std, Pointer Variables
Python: Dynamic Typing
JavaScript: Event Driven

Card Types:
Language Decks: Functions, Libraries, Loops (~40)
Main Deck: Events, Bonuses, Bugs, Variables (100)

Variables:
Pointer, Integer, Boolean, String, Char, Media, Class, Button/Key Press

Loops:
Do (+5), For (requires Integer), While (requires 2 vars)

Libraries:
C++: IOStream, Vector, Winmm, SDL2, GDIplus, Ctime
Python: pygame, numpy, socket
JavaScript: math.js, WebSocket

Functions:
Easy (x11), Medium (x5), Hard (x5), Extreme (x4)
Refer to full rulebook for variable & library requirements.

Bugs, Events, Bonuses: see full rulebook for details
</pre>
</div>
</details>

<h2>Player Info</h2>
<div id="players"></div>

<h2>Selected Function</h2>
<div id="selectedFunction"></div>

<h2>Controls</h2>
<button onclick="drawMain(currentPlayer)">Draw Main Deck</button>
<button onclick="drawLang(currentPlayer)">Draw Language Deck</button>
<button onclick="scoreFunction(currentPlayer)">Play Selected Function</button>
<button onclick="passTurn()">End Turn</button>

<h2>Log</h2>
<div id="log"></div>

<script>
// --- Constants ---
const NUM_PLAYERS = 2;
let currentPlayer = 0;
let selectedFunctionIndex = null;

// --- Game State ---
const mainDeck = [];
const players = Array.from({length: NUM_PLAYERS}, (_,i)=>({
  name: `Player ${i+1}`,
  score: 0,
  hand: [],
  program: [],
  langDeck: []
}));

// --- Card Class ---
function Card(name,type,options={}){
  this.name = name;
  this.type = type;
  this.value = options.value || 0;
  this.reqVars = options.reqVars || 0;
  this.reqLibs = options.reqLibs || [];
  this.difficulty = options.difficulty || 1;
}

// --- Logging ---
function logAction(msg){
  const log = document.getElementById('log');
  log.innerHTML += msg + "<br>";
  log.scrollTop = log.scrollHeight;
}

// --- Render Players ---
function renderPlayers(){
  const container = document.getElementById('players');
  container.innerHTML = "";
  players.forEach((p,pi)=>{
    const div = document.createElement('div');
    div.className = 'card';
    div.innerHTML = `<strong>${p.name}</strong> - Score: ${p.score}<br>
      Hand: <div class="hand">${p.hand.map((c,ci)=>
        `<div class="card ${ci===selectedFunctionIndex?'selected':''}" onclick="selectedFunctionIndex=${ci};renderPlayers()">${c.name}</div>`).join('')}</div>
      Program: <div class="program">${p.program.map(c=>`<div class="card">${c.name}</div>`).join('')}</div>`;
    container.appendChild(div);
  });

  const selDiv = document.getElementById('selectedFunction');
  if(selectedFunctionIndex!==null){
    const c = players[currentPlayer].hand[selectedFunctionIndex];
    selDiv.innerHTML = `<strong>${c.name}</strong> (${c.type}) - Requires ${c.reqVars} variables, Libraries: ${c.reqLibs.join(', ')}`;
  } else selDiv.innerHTML = "None";
}

// --- Game Functions ---
function scoreFunction(playerIndex){
  const player = players[playerIndex];
  if(selectedFunctionIndex === null){
    logAction("No function selected.");
    return;
  }
  const card = player.hand[selectedFunctionIndex];
  if(card.type !== "Function"){ logAction("Selected card is not a Function."); return; }

  const progVars = player.program.filter(c => c.type==="Variable");
  const progLibs = player.program.filter(c => c.type==="Library").map(c=>c.name);

  if(card.reqVars !== undefined && progVars.length < card.reqVars){
    logAction(`Cannot play ${card.name}: requires ${card.reqVars} variable(s). You have ${progVars.length}.`);
    return;
  }
  for(const lib of card.reqLibs){
    if(!progLibs.includes(lib)){
      logAction(`Cannot play ${card.name}: missing Library ${lib}.`);
      return;
    }
  }

  // --- Score Calculation ---
  let score = 0;
  progVars.forEach(v=>{
    switch(v.type){
      case "Integer": score += v.value; break;
      case "Boolean": score += 2; break;
      case "String": score += v.value.length; break;
      case "Char": score += v.value.length; break;
      case "Media": score += v.value; break;
      case "Class": score += (v.value || 0)*2; break;
      case "ButtonPress": score += 4; break;
      default: score += 1;
    }
  });

  const loops = player.program.filter(c=>c.type==="Loop");
  loops.forEach(loop=>{
    if(loop.name === "Do") score += 5;
    else if(loop.name === "For"){
      const intVar = progVars.find(v=>v.type==="Integer");
      if(intVar) score += intVar.value;
    }
    else if(loop.name === "While"){
      if(progVars.length >= 2) score += progVars[0].value + progVars[1].value;
    }
  });

  score *= card.difficulty || 1;
  const bonuses = player.program.filter(c=>c.type==="Bonus");
  bonuses.forEach(b=>{ if(b.value) score += b.value; });

  const nestedFuncs = player.program.filter(c=>c.type==="Function" && c !== card);
  nestedFuncs.forEach(nf => score *= nf.difficulty || 1);

  player.score += score;
  player.program.push(card);
  player.hand.splice(selectedFunctionIndex,1);
  selectedFunctionIndex = null;

  logAction(`${card.name} played for ${score} points! Total: ${player.score}`);
  renderPlayers();
}

function drawLang(playerIndex){
  const player = players[playerIndex];
  if(player.langDeck.length === 0){ logAction("No more Language Deck cards."); return; }
  const drawn = player.langDeck.shift();
  player.hand.push(drawn);
  logAction(`${player.name} drew ${drawn.name} from Language Deck.`);
  renderPlayers();
}

function drawMain(playerIndex){
  if(mainDeck.length === 0){ logAction("Main Deck empty."); return; }
  const card = mainDeck.shift();
  players[playerIndex].hand.push(card);
  logAction(`${players[playerIndex].name} drew ${card.name} from Main Deck.`);
  renderPlayers();
}

function passTurn(){
  currentPlayer = (currentPlayer + 1) % NUM_PLAYERS;
  logAction(`Turn: ${players[currentPlayer].name}`);
}

renderPlayers();
</script>
</body>
</html>
